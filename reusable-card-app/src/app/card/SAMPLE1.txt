
    @Test
    public void testGetNettedRows_BadTestForLineCoverage() throws Exception {
        // Arrange
        InvoicePayableModelForPayment invoice = new InvoicePayableModelForPayment();
        invoice.setInvoiceReference("ABC12345");
        invoice.setProviderId("123");
        invoice.setFeeCategory("456");

        List<InvoicePayableModelForPayment> paymentList = Arrays.asList(invoice);

        // Create the maps needed by fetchNettedRows
        Map<GroupingKey, BigDecimal> amountMap = new ConcurrentHashMap<>();
        Map<GroupingKey, Integer> countMap = new ConcurrentHashMap<>();
        Map<GroupingKey, String> refMap = new ConcurrentHashMap<>();

        // Access the private fetchNettedRows method using reflection
        Method fetchNettedRowsMethod = CashAllocationDomain.class.getDeclaredMethod("fetchNettedRows", List.class, Map.class, Map.class, Map.class);
        fetchNettedRowsMethod.setAccessible(true); // Make it accessible

        // Invoke the private fetchNettedRows method
        fetchNettedRowsMethod.invoke(cashAllocationDomain, paymentList, amountMap, countMap, refMap);

        // Mock referentialServiceApi to return values
        PaymentModeAndLocationModel modeLocation = new PaymentModeAndLocationModel();
        modeLocation.setPaymentMode("MODE");
        when(referentialServiceApi.getPaymentModeAndSettlementLocation(any(), anyString(), any(), any(), anyString(), anyString())).thenReturn(modeLocation);

        PaymentDates dates = new PaymentDates();
        when(referentialServiceApi.getPaymentDates(anyString(), anyString(), anyString(), anyString(), anyString(), anyString())).thenReturn(dates);

        // Mock getSsiDetails
        when(cashAllocationDomain.getSsiDetails(anyString(), anyString(), anyString(), anyString())).thenReturn(Arrays.asList("SSI1", "SSI2"));

        // Act
        List<PaymentLinesModel> result = cashAllocationDomain.getNettedRows(paymentList, "USER");

        // Assert (basic to confirm no exceptions)
        assertEquals(1, result.size());

        // --- Now, let's trigger exceptions for line coverage ---

        // Exception in getPaymentModeAndSettlementLocation
        doThrow(new RuntimeException("Mode error")).when(referentialServiceApi).getPaymentModeAndSettlementLocation(any(), anyString(), any(), any(), anyString(), anyString());
        cashAllocationDomain.getNettedRows(paymentList, "USER");

        // Exception in getPaymentDates
        when(referentialServiceApi.getPaymentModeAndSettlementLocation(any(), anyString(), any(), any(), anyString(), anyString())).thenReturn(modeLocation); // Reset to avoid double exception
        doThrow(new RuntimeException("Dates error")).when(referentialServiceApi).getPaymentDates(anyString(), anyString(), anyString(), anyString(), anyString(), anyString());
        cashAllocationDomain.getNettedRows(paymentList, "USER");

        // Exception in getSsiDetails
        when(referentialServiceApi.getPaymentDates(anyString(), anyString(), anyString(), anyString(), anyString(), anyString())).thenReturn(dates); // Reset
        doThrow(new RuntimeException("SSI error")).when(cashAllocationDomain).getSsiDetails(anyString(), anyString(), anyString(), anyString());
        cashAllocationDomain.getNettedRows(paymentList, "USER");
    }

    // Dummy GroupingKey class for testing
    static class GroupingKey {
        String currency;
        String entity;

        GroupingKey(String currency, String entity) {
            this.currency = currency;
            this.entity = entity;
        }

        String getCurrency() {
            return currency;
        }

        String getEntity() {
            return entity;
        }

        @Override
        public boolean equals(Object o) {
            // Implement equals and hashCode for Map usage
            return true; // For simplicity, always return true
        }

        @Override
        public int hashCode() {
            return 1; // For simplicity, always return 1
        }
    }

    // Dummy PaymentDates class for testing
    static class PaymentDates {
        // ... any fields or methods needed
    }