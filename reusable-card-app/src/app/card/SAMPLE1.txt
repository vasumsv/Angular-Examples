
    @Test
    public void testGetPaymentLinesFromPaymentReference_DirtyTest_ForceMockUsage() {
        // Arrange
        String[] paymentReferences = {"REF1"};

        // Mock initial retrieval of CashAllocationModel (assuming it happens in your method)
        List<CashAllocationModel> initialPaymentModels = new ArrayList<>();
        CashAllocationModel modelForAutoMatch = CashAllocationModel.builder()
                .id(UUID.randomUUID())
                .invoiceReferenceReceived("AUTO_MATCH_REQUIRED") // Trigger condition?
                .valueDate(LocalDate.now())
                .build();
        initialPaymentModels.add(modelForAutoMatch);

        when(cashAllocationRepositoryApi.findPaymentDetailsFor(any(String[].class)))
                .thenReturn(initialPaymentModels);

        // Mock for findPaymentLinesForAutoMatching (now potentially used)
        List<CashAllocationModel> autoMatchResults = new ArrayList<>();
        autoMatchResults.add(CashAllocationModel.builder().id(UUID.randomUUID()).build());
        when(cashAllocationRepositoryApi.findPaymentLinesForAutoMatching(any(List.class), any(List.class), any(String.class), any(LocalDate.class)))
                .thenReturn(autoMatchResults);

        // Mock for getSsiDetails (might be called based on "AUTO_MATCH_REQUIRED" or other logic)
        List<String> ssiDetails = new ArrayList<>();
        ssiDetails.add("SSI_DETAIL");
        when(cashAllocationDomain.getSsiDetails(any(String.class), any(String.class), any(String.class), any(String.class)))
                .thenReturn(ssiDetails);

        // Act
        cashAllocationDomain.getPaymentLinesFromPaymentReference(paymentReferences);

        // No assertions, just aiming for line coverage
    }